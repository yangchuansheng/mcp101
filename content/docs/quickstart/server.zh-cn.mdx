---
title: "服务器开发"
description: "了解如何构建自己的服务器，以便在 Claude 桌面版及其他客户端中使用。"
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { Plug, Grid3x3, Bug, MessageCircle } from 'lucide-react';

在本教程中，我们将构建一个简单的 MCP 天气服务器，并将其连接到 Claude 桌面版主机。我们将从基本设置开始，然后逐步过渡到更复杂的用例。

### 我们将构建什么

目前，大多数大语言模型还不具备直接获取实时天气预报和严重天气警报的能力。通过 MCP 技术，我们可以轻松解决这一问题！

我们将创建一个服务器，提供两个核心工具：`get-alerts` (获取警报) 和 `get-forecast` (获取预报)。随后，我们会将这个服务器连接到 MCP 主机，本教程中我们选择使用 Claude 桌面版作为示例：

![](/images/weather-alerts.png)

![](/images/current-weather.png)

<Callout type="info">
该服务器实际上可以连接到任何支持MCP的客户端。我们选择Claude桌面版仅是为了演示的简便性。此外，我们还提供了[如何构建自己的客户端](/quickstart/client)的指南和[其他可用客户端的列表](/clients)。
</Callout>

<Accordions type="single">
  <Accordion title="为什么选择Claude桌面版而不是Claude.ai？">
    这是因为我们开发的服务器在本地运行，而目前MCP仅支持桌面主机应用。不过请放心，远程主机功能正在积极开发中，未来将会支持更多平台。
  </Accordion>
</Accordions>

### MCP 核心概念

MCP 服务器可以提供三种主要类型的功能：

1. **资源 (Resources)**：客户端可读取的类文件数据，例如 API 响应结果或文件内容等
2. **工具 (Tools)**：可由大语言模型调用的函数，这些调用会先获取用户批准
3. **提示 (Prompts)**：帮助用户高效完成特定任务的预设模板

本教程将主要聚焦于如何实现和使用工具功能。

<Tabs items={['Python', 'Node', 'Java', 'Kotlin', 'C#']}>
<Tab value='Python'>

让我们开始构建我们的天气服务器吧！[您可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-python)

### 前提知识

本快速入门假设您熟悉：
- Python
- 像 Claude 这样的大语言模型

### 系统要求

- 已安装 Python 3.10 或更高版本。
- 您必须使用 Python MCP SDK 1.2.0 或更高版本。

### 设置您的环境

首先，让我们安装 `uv` 并设置 Python 项目和环境：

<Tabs items={['MacOS/Linux', 'Windows']}>
```bash tab="MacOS/Linux"
curl -LsSf https://astral.sh/uv/install.sh | sh
```

```powershell tab="Windows"
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```
</Tabs>

安装完成后请确保重启终端，以确保 `uv` 命令能被正确识别。

现在，让我们创建并设置我们的项目：

<Tabs items={['MacOS/Linux', 'Windows']}>
  ```bash tab="MacOS/Linux"
  # 为我们的项目创建一个新目录
  uv init weather
  cd weather
  
  # 创建虚拟环境并激活它
  uv venv
  source .venv/bin/activate
  
  # 安装依赖项
  uv add "mcp[cli]" httpx
  
  # 创建我们的服务器文件
  touch weather.py
  ```
  
  ```powershell tab="Windows"
  # 为我们的项目创建一个新目录
  uv init weather
  cd weather
  
  # 创建虚拟环境并激活它
  uv venv
  .venv\Scripts\activate
  
  # 安装依赖项
  uv add mcp[cli] httpx
  
  # 创建我们的服务器文件
  new-item weather.py
  ```
</Tabs>

现在让我们开始构建您的服务器。

## 构建您的服务器

### 导入包和设置实例

将以下代码添加到您的 `weather.py` 文件顶部：
```python
from typing import Any
import httpx
from mcp.server.fastmcp import FastMCP

# 初始化FastMCP服务器
mcp = FastMCP("weather")

# 常量
NWS_API_BASE = "https://api.weather.gov"
USER_AGENT = "weather-app/1.0"
```

FastMCP 类使用 Python 类型提示和文档字符串自动生成工具定义，这使得创建和维护 MCP 工具变得简单。

### 辅助函数

接下来，让我们添加辅助函数，用于查询和格式化来自国家气象服务 API 的数据：

```python
async def make_nws_request(url: str) -> dict[str, Any] | None:
    """向NWS API发送请求并进行适当的错误处理。"""
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/geo+json"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

def format_alert(feature: dict) -> str:
    """将警报特征格式化为可读字符串。"""
    props = feature["properties"]
    return f"""
Event: {props.get('event', 'Unknown')}  # 事件类型
Area: {props.get('areaDesc', 'Unknown')}  # 影响区域
Severity: {props.get('severity', 'Unknown')}  # 严重程度
Description: {props.get('description', 'No description available')}  # 详细描述
Instructions: {props.get('instruction', 'No specific instructions provided')}  # 安全指南
"""
```

### 实现工具执行

工具执行处理程序负责实际执行每个工具的逻辑。让我们添加它：

```python
@mcp.tool()
async def get_alerts(state: str) -> str:
    """获取美国各州的天气警报。
    
    Args:
        state: 美国州的两字母代码（例如CA代表加利福尼亚州, NY代表纽约州）
    """
    url = f"{NWS_API_BASE}/alerts/active/area/{state}"
    data = await make_nws_request(url)

    if not data or "features" not in data:
        return "无法获取警报信息或未找到相关警报。"

    if not data["features"]:
        return "该州目前没有活跃的天气警报。"

    alerts = [format_alert(feature) for feature in data["features"]]
    return "\n---\n".join(alerts)

@mcp.tool()
async def get_forecast(latitude: float, longitude: float) -> str:
    """获取指定位置的天气预报。
    
    Args:
        latitude: 位置的纬度
        longitude: 位置的经度
    """
    # 首先获取预报网格端点
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    if not points_data:
        return "无法为该位置获取预报数据。"

    # 从点响应中获取预报URL
    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    if not forecast_data:
        return "无法获取详细预报。"

    # 将时段格式化为可读的预报
    periods = forecast_data["properties"]["periods"]
    forecasts = []
    for period in periods[:5]:  # 只显示接下来的5个时段
        forecast = f"""
{period['name']}:  # 时段名称（如：今晚、明天）
Temperature: {period['temperature']}°{period['temperatureUnit']}  # 温度和单位
Wind: {period['windSpeed']} {period['windDirection']}  # 风速和风向
Forecast: {period['detailedForecast']}  # 详细天气情况
"""
        forecasts.append(forecast)

    return "\n---\n".join(forecasts)
```

### 运行服务器

最后，让我们初始化并运行服务器：

```python
if __name__ == "__main__":
    # 初始化并运行服务器
    mcp.run(transport='stdio')
```

您的服务器已经完成！运行 `uv run weather.py` 来确认一切正常工作。

现在让我们从一个现有的 MCP 主机 (Claude 桌面版) 测试您的服务器。

## 使用 Claude 桌面版测试您的服务器

<Callout type="info">
Claude桌面版目前尚未支持Linux系统。如果您使用的是Linux，可以参考[构建客户端](/quickstart/client)教程，构建一个可连接到我们刚刚创建的服务器的MCP客户端。
</Callout>

首先，请确保您已经安装了 Claude 桌面版。[您可以在这里下载最新版本](https://claude.ai/download)。如果您已经安装了 Claude 桌面版，**请务必确保它已更新至最新版本**。

接下来，我们需要为您的 MCP 服务器配置 Claude 桌面版。要完成这一步，请在文本编辑器中打开 Claude 桌面版的配置文件，路径为 `~/Library/Application Support/Claude/claude_desktop_config.json`。如果该文件不存在，您需要创建它。

例如，如果您已安装 [VS Code](https://code.visualstudio.com/) 编辑器：

<Tabs>
<Tab value="MacOS/Linux">
```bash
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```
</Tab>
<Tab value="Windows">
```powershell
code $env:AppData\Claude\claude_desktop_config.json
```
</Tab>
</Tabs>

然后，您需要在 `mcpServers` 键下添加您的服务器配置。请注意，只有当至少配置了一个服务器时，Claude 桌面版中的 MCP 相关界面元素才会显示。

在本例中，我们将添加一个天气服务器，配置如下：

<Tabs>
<Tab value="MacOS/Linux">
```json Python
{
    "mcpServers": {
        "weather": {
            "command": "uv",
            "args": [
                "--directory",
                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
                "run",
                "weather.py"
            ]
        }
    }
}
```
</Tab>
<Tab value="Windows">
```json Python
{
    "mcpServers": {
        "weather": {
            "command": "uv",
            "args": [
                "--directory",
                "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather",
                "run",
                "weather.py"
            ]
        }
    }
}
```
</Tab>
</Tabs>

<Callout type="warn">
您可能需要在`command`字段中使用`uv`可执行文件的完整路径。您可以通过在MacOS/Linux系统上运行`which uv`命令或在Windows系统上运行`where uv`命令来获取这个路径。
</Callout>

<Callout type="info">
务必使用服务器的绝对路径，而不是相对路径。请将示例中的"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather"替换为您实际项目的完整路径。
</Callout>

这段配置向 Claude 桌面版说明：
1。有一个名为 "weather" 的 MCP 服务器
2。需要通过运行 `uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py` 命令来启动它

完成配置后，保存文件并重新启动 **Claude 桌面版**应用程序。

</Tab>

<Tab value='Node'>
让我们开始构建我们的天气服务器！[您可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-typescript)

### 前提知识

本快速入门假设您熟悉：
- TypeScript
- 像 Claude 这样的大语言模型

### 系统要求

对于 TypeScript 实现，请确保您安装了最新版本的 Node.js 环境。

### 设置您的环境

首先，如果您尚未安装 Node.js 和 npm，请先完成安装。您可以从 [nodejs.org](https://nodejs.org/) 官网下载安装包。
安装完成后，可通过以下命令验证您的 Node.js 环境：
```bash
node --version
npm --version
```
本教程要求使用 Node.js 16 或更高版本。

现在，让我们创建并设置我们的项目：

<Tabs items={['MacOS/Linux', 'Windows']}>
```bash tab="MacOS/Linux"
# 为我们的项目创建一个新目录
mkdir weather
cd weather

# 初始化一个新的 npm 项目
npm init -y

# 安装依赖项
npm install @modelcontextprotocol/sdk zod
npm install -D @types/node typescript

# 创建我们的文件
mkdir src
touch src/index.ts
```

```powershell tab="Windows"
# 为我们的项目创建一个新目录
md weather
cd weather

# 初始化一个新的npm项目
npm init -y

# 安装依赖项
npm install @modelcontextprotocol/sdk zod
npm install -D @types/node typescript

# 创建我们的文件
md src
new-item src\index.ts
```
</Tabs>

更新您的 package.json，添加 type："module" 和构建脚本：

```json package.json
{
  "type": "module",
  "bin": {
    "weather": "./build/index.js"
  },
  "scripts": {
    "build": "tsc && chmod 755 build/index.js"
  },
  "files": [
    "build"
  ],
}
```

在项目根目录创建一个 `tsconfig.json` 文件：

```json tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

现在让我们开始构建您的服务器。

## 构建您的服务器

### 导入包和设置实例

在您的 `src/index.ts` 顶部添加以下内容：
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const NWS_API_BASE = "https://api.weather.gov";
const USER_AGENT = "weather-app/1.0";

// 创建服务器实例
const server = new McpServer({
  name: "weather",
  version: "1.0.0",
  capabilities: {
    resources: {},
    tools: {},
  },
});
```

### 辅助函数

接下来，让我们添加用于查询和格式化来自国家气象服务 API 数据的辅助函数：

```typescript
// 用于发送NWS API请求的辅助函数
async function makeNWSRequest<T>(url: string): Promise<T | null> {
  const headers = {
    "User-Agent": USER_AGENT,
    Accept: "application/geo+json",
  };

  try {
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return (await response.json()) as T;
  } catch (error) {
    console.error("Error making NWS request:", error);
    return null;
  }
}

interface AlertFeature {
  properties: {
    event?: string;      // 事件类型
    areaDesc?: string;   // 影响区域
    severity?: string;   // 严重程度
    status?: string;     // 状态
    headline?: string;   // 标题
  };
}

// 格式化警报数据
function formatAlert(feature: AlertFeature): string {
  const props = feature.properties;
  return [
    `Event: ${props.event || "Unknown"}`,         // 事件类型
    `Area: ${props.areaDesc || "Unknown"}`,       // 影响区域
    `Severity: ${props.severity || "Unknown"}`,   // 严重程度
    `Status: ${props.status || "Unknown"}`,       // 状态
    `Headline: ${props.headline || "No headline"}`, // 标题
    "---",
  ].join("\n");
}

interface ForecastPeriod {
  name?: string;               // 时段名称
  temperature?: number;        // 温度值
  temperatureUnit?: string;    // 温度单位
  windSpeed?: string;          // 风速
  windDirection?: string;      // 风向
  shortForecast?: string;      // 简短预报
}

interface AlertsResponse {
  features: AlertFeature[];
}

interface PointsResponse {
  properties: {
    forecast?: string;
  };
}

interface ForecastResponse {
  properties: {
    periods: ForecastPeriod[];
  };
}
```

### 实现工具执行

工具执行处理程序负责实际执行每个工具的逻辑。让我们添加它：

```typescript
// 注册天气工具
server.tool(
  "get-alerts",
  "获取某个州的天气警报",
  {
    state: z.string().length(2).describe("两字母州代码（例如CA代表加利福尼亚州, NY代表纽约州）"),
  },
  async ({ state }) => {
    const stateCode = state.toUpperCase();
    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

    if (!alertsData) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取警报数据，请稍后再试。",
          },
        ],
      };
    }

    const features = alertsData.features || [];
    if (features.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: `${stateCode}当前没有活跃的天气警报。`,
          },
        ],
      };
    }

    const formattedAlerts = features.map(formatAlert);
    const alertsText = `${stateCode}的活跃天气警报：\n\n${formattedAlerts.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: alertsText,
        },
      ],
    };
  },
);

server.tool(
  "get-forecast",
  "获取特定位置的天气预报",
  {
    latitude: z.number().min(-90).max(90).describe("位置的纬度"),
    longitude: z.number().min(-180).max(180).describe("位置的经度"),
  },
  async ({ latitude, longitude }) => {
    // 首先获取预报网格端点
    const pointsUrl = `${NWS_API_BASE}/points/${latitude},{longitude}`;
    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

    if (!pointsData) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取坐标：" + latitude + ", " + longitude + "的网格点数据。此位置可能不受NWS API支持（仅支持美国位置）。",
          },
        ],
      };
    }

    // 从点响应中获取预报URL
    const forecastUrl = pointsData.properties?.forecast;
    if (!forecastUrl) {
      return {
        content: [
          {
            type: "text",
            text: "无法从网格点数据获取预报URL",
          },
        ],
      };
    }

    // 获取预报数据
    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
    if (!forecastData) {
      return {
        content: [
          {
            type: "text",
            text: "无法获取预报数据",
          },
        ],
      };
    }

    // 将时段格式化为可读的预报
    const periods = forecastData.properties?.periods || [];
    if (periods.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: "没有可用的预报时段",
          },
        ],
      };
    }

    // 格式化预报时段
    const formattedForecast = periods.map((period: ForecastPeriod) =>
      [
        `${period.name || "未知"}:`,                                    // 时段名称（如：今晚、明天）
        `温度: ${period.temperature || "未知"}°${period.temperatureUnit || "F"}`,  // 温度和单位
        `风况: ${period.windSpeed || "未知"} ${period.windDirection || ""}`,      // 风速和风向
        `${period.shortForecast || "无可用预报"}`,                      // 简短天气描述
        "---",
      ].join("\n"),
    );

    const forecastText = `坐标 ${latitude}, ${longitude} 的天气预报：\n\n${formattedForecast.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: forecastText,
        },
      ],
    };
  },
);
```

### 运行服务器

最后，实现运行服务器的主函数：

```typescript
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Weather MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});
```

确保运行 `npm run build` 来构建您的服务器！这是使您的服务器能够连接的非常重要的步骤。

现在让我们从一个现有的 MCP 主机 (Claude 桌面版) 测试您的服务器。

## 使用 Claude 桌面版测试您的服务器

<Callout type="info">
Claude桌面版目前尚未支持Linux系统。如果您使用的是Linux，可以参考[构建客户端](/quickstart/client)教程，构建一个可连接到我们刚刚创建的服务器的MCP客户端。
</Callout>

首先，请确保您已经安装了 Claude 桌面版。[您可以在此处下载最新版本](https://claude.ai/download)。如果您已经安装了 Claude 桌面版，**请务必确保它已更新至最新版本**。

接下来，我们需要为您的 MCP 服务器配置 Claude 桌面版。要完成这一步，请在文本编辑器中打开 Claude 桌面版的配置文件，路径为 `~/Library/Application Support/Claude/claude_desktop_config.json`。如果该文件不存在，您需要创建它。

例如，如果您已安装 [VS Code](https://code.visualstudio.com/) 编辑器：

<Tabs items={['MacOS/Linux', 'Windows']}>
<Tab value="MacOS/Linux">
```bash
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```
</Tab>
<Tab value="Windows">
```powershell
code $env:AppData\Claude\claude_desktop_config.json
```
</Tab>
</Tabs>

然后，您需要在 `mcpServers` 键下添加您的服务器配置。请注意，只有当至少配置了一个服务器时，Claude 桌面版中的 MCP 相关界面元素才会显示。

在本例中，我们将添加一个天气服务器，配置如下：

<Tabs items={['MacOS/Linux', 'Windows']}>
<Tab value="MacOS/Linux">
<Tabs>
```json Node
{
    "mcpServers": {
        "weather": {
            "command": "node",
            "args": [
                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"
            ]
        }
    }
}
```
</Tabs>
</Tab>
<Tab value="Windows">
<Tabs>
```json Node
{
    "mcpServers": {
        "weather": {
            "command": "node",
            "args": [
                "C:\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\index.js"
            ]
        }
    }
}
```
</Tabs>
</Tab>
</Tabs>

<Callout type="info">
务必使用服务器的绝对路径，而不是相对路径。请将示例中的路径替换为您实际项目的完整路径。
</Callout>

这段配置向 Claude 桌面版说明：
1。有一个名为 "weather" 的 MCP 服务器
2。需要通过运行 `node /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js` 命令来启动它

完成配置后，保存文件并重新启动 **Claude 桌面版**应用程序。

</Tab>

<Tab value='Java'>

<Callout type="info">
这是一个基于Spring AI MCP自动配置和启动器的快速入门演示。
若要了解如何手动创建同步和异步MCP服务器，请查阅[Java SDK服务器](/sdk/java/mcp-server)文档。
</Callout>


让我们开始构建我们的天气服务器！
[您可以在这里找到我们将要构建的完整代码。](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-stdio-server)

更多信息，请参阅 [MCP 服务器引导启动器](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html)参考文档。
有关手动 MCP 服务器实现，请参考 [MCP 服务器 Java SDK 文档](/sdk/java/mcp-server)。

### 系统要求

- 已安装 Java 17 或更高版本。
- [Spring Boot 3.3.x](https://docs.spring.io/spring-boot/installing.html) 或更高版本

### 设置您的环境

使用 [Spring Initializer](https://start.spring.io/) 引导项目。

您需要添加以下依赖项：

<Tabs items={['Maven', 'Gradle']}>
  <Tab value="Maven">
  ```xml
  <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-mcp-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
        </dependency>
  </dependencies>
  ```
  </Tab>
  <Tab value="Gradle">
  ```groovy
  dependencies {
    implementation platform("org.springframework.ai:spring-ai-starter-mcp-server")
    implementation platform("org.springframework:spring-web")   
  }
  ```
  </Tab>
</Tabs>

然后通过设置应用程序属性来配置您的应用程序：

<Tabs items={['application.properties', 'application.yml']}>

```bash tab="application.properties"
spring.main.bannerMode=off
logging.pattern.console=
```

```yaml tab="application.yml"
logging:
  pattern:
    console:
spring:
  main:
    banner-mode: off
```
</Tabs>

[服务器配置属性](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html#_configuration_properties)文档列出了所有可用的属性。

现在让我们开始构建您的服务器。

## 构建您的服务器

### 天气服务

让我们实现一个 [WeatherService.java](https://github.com/spring-projects/spring-ai-examples/blob/main/model-context-protocol/weather/starter-stdio-server/src/main/java/org/springframework/ai/mcp/sample/server/WeatherService.java)，它使用 REST 客户端从国家气象服务 API 查询数据：

```java
@Service
public class WeatherService {

	private final RestClient restClient;

	public WeatherService() {
		this.restClient = RestClient.builder()
			.baseUrl("https://api.weather.gov")
			.defaultHeader("Accept", "application/geo+json")
			.defaultHeader("User-Agent", "WeatherApiClient/1.0 (your@email.com)")
			.build();
	}

  @Tool(description = "Get weather forecast for a specific latitude/longitude")
  public String getWeatherForecastByLocation(
      double latitude,   // Latitude coordinate
      double longitude   // Longitude coordinate
  ) {
      // Returns detailed forecast including:
      // - Temperature and unit
      // - Wind speed and direction
      // - Detailed forecast description
  }
	
  @Tool(description = "Get weather alerts for a US state")
  public String getAlerts(
      @ToolParam(description = "Two-letter US state code (e.g. CA, NY") String state)
  ) {
      // Returns active alerts including:
      // - Event type
      // - Affected area
      // - Severity
      // - Description
      // - Safety instructions
  }

  // ......
}
```

`@Service` 注解会在应用程序上下文中自动注册服务。
Spring AI 的 `@Tool` 注解使创建和维护 MCP 工具变得简单。

自动配置将自动将这些工具注册到 MCP 服务器。

### 创建您的启动应用程序

```java
@SpringBootApplication
public class McpServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(McpServerApplication.class, args);
	}

	@Bean
	public ToolCallbackProvider weatherTools(WeatherService weatherService) {
		return  MethodToolCallbackProvider.builder().toolObjects(weatherService).build();
	}
}
```

使用 `MethodToolCallbackProvider` 工具将 `@Tools` 转换为 MCP 服务器使用的可执行回调。

### 运行服务器

最后，让我们构建服务器：

```bash
./mvnw clean install
```

这将在 `target` 文件夹中生成一个 `mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar` 文件。

现在让我们从现有的 MCP 主机 (Claude 桌面版) 测试您的服务器。

## 使用 Claude 桌面版测试您的服务器

<Callout type="info">
Claude桌面版在Linux上尚不可用。
</Callout>

首先，确保您已安装 Claude 桌面版。
[您可以在这里安装最新版本](https://claude.ai/download)。如果您已经安装了 Claude 桌面版，**请确保它已更新到最新版本。**

我们需要为您想要使用的 MCP 服务器配置 Claude 桌面版。
要做到这一点，请在文本编辑器中打开您的 Claude 桌面版应用配置文件，路径为 `~/Library/Application Support/Claude/claude_desktop_config.json`。
如果该文件不存在，请创建它。

例如，如果您已安装 [VS Code](https://code.visualstudio.com/)：

<Tabs items={['MacOS/Linux', 'Windows']}>
  <Tab value="MacOS/Linux">
  ```bash
  code ~/Library/Application\ Support/Claude/claude_desktop_config.json
  ```
  </Tab>
  <Tab value="Windows">
  ```powershell
  code $env:AppData\Claude\claude_desktop_config.json
  ```
  </Tab>
</Tabs>

然后您将在 `mcpServers` 键中添加您的服务器。只有在至少一个服务器正确配置的情况下，MCP UI 元素才会在 Claude 桌面版中显示。

在这种情况下，我们将添加单个天气服务器，如下所示：

<Tabs items={['MacOS/Linux', 'Windows']}>
  <Tab value="MacOS/Linux">
  ```json java
  {
    "mcpServers": {
      "spring-ai-mcp-weather": {
        "command": "java",
        "args": [
          "-Dspring.ai.mcp.server.stdio=true",
          "-jar",
          "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
        ]
      }
    }
  }
  ```
  </Tab>

  <Tab value="Windows">
  ```json java
  {
    "mcpServers": {
      "spring-ai-mcp-weather": {
        "command": "java",
        "args": [
          "-Dspring.ai.mcp.server.stdio=true",
          "-jar",
          "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
        ]
      }
    }
  }
  ```
  </Tab>
</Tabs>

这告诉 Claude 桌面版：
1。有一个名为 "spring-ai-mcp-weather" 的 MCP 服务器
2。通过运行 `java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar` 来启动它

完成配置后，保存文件并重新启动 **Claude 桌面版**。

## 使用 Java 客户端测试您的服务器

### 手动创建 MCP 客户端

使用 `McpClient` 连接到服务器：

```java
var stdioParams = ServerParameters.builder("java")
  .args("-jar", "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar")
  .build();

var stdioTransport = new StdioClientTransport(stdioParams);

var mcpClient = McpClient.sync(stdioTransport).build();

mcpClient.initialize();

ListToolsResult toolsList = mcpClient.listTools();

CallToolResult weather = mcpClient.callTool(
  new CallToolRequest("getWeatherForecastByLocation",
      Map.of("latitude", "47.6062", "longitude", "-122.3321")));

CallToolResult alert = mcpClient.callTool(
  new CallToolRequest("getAlerts", Map.of("state", "NY")));

mcpClient.closeGracefully();
```

### 使用 MCP 客户端启动器

创建一个使用 `spring-ai-starter-mcp-client` 依赖项的新启动器应用程序：

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-mcp-client</artifactId>
</dependency>
```

并设置 `spring.ai.mcp.client.stdio.servers-configuration` 属性指向您的 `claude_desktop_config.json`。
您可以重用现有的 Anthropic 桌面配置：

```properties
spring.ai.mcp.client.stdio.servers-configuration=file:PATH/TO/claude_desktop_config.json
```

当您启动客户端应用程序时，自动配置将自动从 claude_desktop_config.json 创建 MCP 客户端。

更多信息，请参阅 [MCP 客户端启动器](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-client-docs.html)参考文档。

## 更多 Java MCP 服务器示例

[starter-webflux-server](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-webflux-server) 演示了如何使用 SSE 传输创建 MCP 服务器。
它展示了如何使用 Spring Boot 的自动配置功能定义和注册 MCP 工具、资源和提示。

</Tab>

<Tab value='Kotlin'>
让我们开始构建我们的天气服务器！[您可以在这里找到我们将要构建的完整代码。](https://github.com/modelcontextprotocol/kotlin-sdk/tree/main/samples/weather-stdio-server)

### 前提知识

本快速入门假设您熟悉：
- Kotlin
- 像 Claude 这样的大语言模型

### 系统要求

- 已安装 Java 17 或更高版本。

### 设置您的环境

首先，如果您尚未安装 `java` 和 `gradle`，请先完成安装。
您可以从 [Oracle JDK 官方网站](https://www.oracle.com/java/technologies/downloads/)下载 `java`。
安装完成后，可通过以下命令验证您的 Java 环境：
```bash
java --version
```

现在，让我们创建并设置我们的项目：

<Tabs items={['MacOS/Linux', 'Windows']}>
```bash tab="MacOS/Linux"
# 为我们的项目创建一个新目录
mkdir weather
cd weather

# 初始化一个新的 Kotlin 项目
gradle init
```

```powershell tab="Windows"
# 为我们的项目创建一个新目录
md weather
cd weather

# 初始化一个新的Kotlin项目
gradle init
```
</Tabs>

运行 `gradle init` 命令后，您将看到创建项目的选项。
选择**应用程序**作为项目类型，**Kotlin** 作为编程语言，以及 **Java 17** 作为 Java 版本。

或者，您也可以使用 [IntelliJ IDEA 项目向导](https://kotlinlang.org/docs/jvm-get-started.html)来创建 Kotlin 应用程序。

创建项目后，在构建脚本中添加以下依赖项：
<Tabs items={['build.gradle.kts', 'build.gradle']}>
```kotlin tab="build.gradle.kts"
val mcpVersion = "0.4.0"
val slf4jVersion = "2.0.9"
val ktorVersion = "3.1.1"

dependencies {
    implementation("io.modelcontextprotocol:kotlin-sdk:$mcpVersion")
    implementation("org.slf4j:slf4j-nop:$slf4jVersion")
    implementation("io.ktor:ktor-client-content-negotiation:$ktorVersion")
    implementation("io.ktor:ktor-serialization-kotlinx-json:$ktorVersion")
}
```

```groovy tab="build.gradle"
dependencies {
    implementation "io.modelcontextprotocol:kotlin-sdk:$mcpVersion"
    implementation "org.slf4j:slf4j-nop:$slf4jVersion"
    implementation "io.ktor:ktor-client-content-negotiation:$ktorVersion"
    implementation "io.ktor:ktor-serialization-kotlinx-json:$ktorVersion"
}
```
</Tabs>

还需要将以下插件添加到您的构建脚本中：
<Tabs items={['build.gradle.kts', 'build.gradle']}>
```kotlin tab="build.gradle.kts"
plugins {
    kotlin("plugin.serialization") version "your_version_of_kotlin"  // 替换为您使用的Kotlin版本
    id("com.github.johnrengelman.shadow") version "8.1.1"
}
```

```groovy tab="build.gradle"
plugins {
    id 'org.jetbrains.kotlin.plugin.serialization' version 'your_version_of_kotlin'  // 替换为您使用的Kotlin版本
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}
```
</Tabs>

现在让我们开始构建您的服务器。

## 构建您的服务器

### 设置实例

首先，添加一个服务器初始化函数：

```kotlin
// 运行MCP服务器的主函数
fun `run mcp server`() {
    // 创建具有基本实现的MCP服务器实例
    val server = Server(
        Implementation(
            name = "weather",           // 服务器名称为"weather"
            version = "1.0.0"           // 实现的版本号
        ),
        ServerOptions(
            capabilities = ServerCapabilities(tools = ServerCapabilities.Tools(listChanged = true))
        )
    )

    // 使用标准输入/输出创建服务器通信通道
    val transport = StdioServerTransport(
        System.`in`.asInput(),
        System.out.asSink().buffered()
    )

    runBlocking {
        server.connect(transport)
        val done = Job()
        server.onClose {
            done.complete()
        }
        done.join()
    }
}
```

### 天气 API 辅助函数

接下来，让我们添加用于查询和格式化国家气象服务 API 数据的函数和数据类：

```kotlin
// 扩展函数，用于获取指定纬度和经度的天气预报信息
suspend fun HttpClient.getForecast(latitude: Double, longitude: Double): List<String> {
    val points = this.get("/points/$latitude,$longitude").body<Points>()
    val forecast = this.get(points.properties.forecast).body<Forecast>()
    return forecast.properties.periods.map { period ->
        """
            ${period.name}:                                     // 时段名称（如：今晚、明天）
            Temperature: ${period.temperature} ${period.temperatureUnit}   // 温度和单位
            Wind: ${period.windSpeed} ${period.windDirection}   // 风速和风向
            Forecast: ${period.detailedForecast}                // 详细天气情况
        """.trimIndent()
    }
}

// 扩展函数，用于获取给定州的天气警报
suspend fun HttpClient.getAlerts(state: String): List<String> {
    val alerts = this.get("/alerts/active/area/$state").body<Alert>()
    return alerts.features.map { feature ->
        """
            Event: ${feature.properties.event}                  // 事件类型
            Area: ${feature.properties.areaDesc}                // 影响区域
            Severity: ${feature.properties.severity}            // 严重程度
            Description: ${feature.properties.description}      // 详细描述
            Instruction: ${feature.properties.instruction}      // 安全指南
        """.trimIndent()
    }
}

// API响应数据类定义
@Serializable
data class Points(
    val properties: Properties
) {
    @Serializable
    data class Properties(val forecast: String)  // 预报URL
}

@Serializable
data class Forecast(
    val properties: Properties
) {
    @Serializable
    data class Properties(val periods: List<Period>)  // 预报时段列表

    @Serializable
    data class Period(
        val number: Int,                            // 时段序号
        val name: String,                           // 时段名称
        val startTime: String,                      // 开始时间
        val endTime: String,                        // 结束时间
        val isDaytime: Boolean,                     // 是否白天
        val temperature: Int,                       // 温度值
        val temperatureUnit: String,                // 温度单位
        val temperatureTrend: String,               // 温度趋势
        val probabilityOfPrecipitation: JsonObject, // 降水概率
        val windSpeed: String,                      // 风速
        val windDirection: String,                  // 风向
        val shortForecast: String,                  // 简短预报
        val detailedForecast: String,               // 详细预报
    )
}

@Serializable
data class Alert(
    val features: List<Feature>  // 警报特征列表
) {
    @Serializable
    data class Feature(
        val properties: Properties  // 警报属性
    )

    @Serializable
    data class Properties(
        val event: String,          // 事件类型
        val areaDesc: String,       // 影响区域
        val severity: String,       // 严重程度
        val description: String,    // 详细描述
        val instruction: String?,   // 安全指南（可能为空）
    )
}
```

### 实现工具执行

工具执行处理程序负责实际执行每个工具的逻辑。让我们添加它们：

```kotlin
// 创建一个具有默认请求配置和JSON序列化功能的HTTP客户端
val httpClient = HttpClient {
    defaultRequest {
        url("https://api.weather.gov")  // 设置API基础URL
        headers {
            append("Accept", "application/geo+json")  // 接受GeoJSON格式
            append("User-Agent", "WeatherApiClient/1.0")  // 设置用户代理
        }
        contentType(ContentType.Application.Json)  // 设置内容类型
    }
    // 安装内容协商插件用于JSON序列化/反序列化
    install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
}

// 注册一个按州获取天气警报的工具
server.addTool(
    name = "get_alerts",
    description = """
        获取美国各州的天气警报，输入为两字母州代码（例如CA代表加利福尼亚州, NY代表纽约州）
    """.trimIndent(),
    inputSchema = Tool.Input(
        properties = buildJsonObject {
            putJsonObject("state") {
                put("type", "string")
                put("description", "两字母州代码（例如CA代表加利福尼亚州, NY代表纽约州）")
            }
        },
        required = listOf("state")  // 指定state参数为必填项
    )
) { request ->
    val state = request.arguments["state"]?.jsonPrimitive?.content
    if (state == null) {
        return@addTool CallToolResult(
            content = listOf(TextContent("需要提供'state'参数（两字母州代码）。"))
        )
    }

    val alerts = httpClient.getAlerts(state)

    CallToolResult(content = alerts.map { TextContent(it) })
}

// 注册一个按纬度和经度获取天气预报的工具
server.addTool(
    name = "get_forecast",
    description = """
        获取指定位置的天气预报，需要提供位置的纬度和经度坐标
    """.trimIndent(),
    inputSchema = Tool.Input(
        properties = buildJsonObject {
            putJsonObject("latitude") { 
                put("type", "number")
                put("description", "位置的纬度坐标") 
            }
            putJsonObject("longitude") { 
                put("type", "number")
                put("description", "位置的经度坐标") 
            }
        },
        required = listOf("latitude", "longitude")  // 指定这两个参数均为必填项
    )
) { request ->
    val latitude = request.arguments["latitude"]?.jsonPrimitive?.doubleOrNull
    val longitude = request.arguments["longitude"]?.jsonPrimitive?.doubleOrNull
    if (latitude == null || longitude == null) {
        return@addTool CallToolResult(
            content = listOf(TextContent("需要同时提供'latitude'（纬度）和'longitude'（经度）参数。"))
        )
    }

    val forecast = httpClient.getForecast(latitude, longitude)

    CallToolResult(content = forecast.map { TextContent(it) })
}
```

### 运行服务器

最后，实现运行服务器的主函数：

```kotlin
fun main() = `run mcp server`()
```

确保运行 `./gradlew build` 命令来构建您的服务器！这是使您的服务器能够连接的非常重要的步骤。

现在让我们从一个现有的 MCP 主机 (Claude 桌面版) 测试您的服务器。

## 使用 Claude 桌面版测试您的服务器

<Callout type="info">
Claude桌面版目前尚未支持Linux系统。如果您使用的是Linux，可以参考[构建客户端](/quickstart/client)教程，构建一个可连接到我们刚刚创建的服务器的MCP客户端。
</Callout>

首先，请确保您已经安装了 Claude 桌面版。[您可以在此处下载最新版本](https://claude.ai/download)。如果您已经安装了 Claude 桌面版，**请务必确保它已更新至最新版本**。

接下来，我们需要为您的 MCP 服务器配置 Claude 桌面版。要完成这一步，请在文本编辑器中打开 Claude 桌面版的配置文件，路径为 `~/Library/Application Support/Claude/claude_desktop_config.json`。如果该文件不存在，您需要创建它。

例如，如果您已安装 [VS Code](https://code.visualstudio.com/) 编辑器：

<Tabs items={['MacOS/Linux', 'Windows']}>
  <Tab value="MacOS/Linux">
  ```bash
  code ~/Library/Application\ Support/Claude/claude_desktop_config.json
  ```
  </Tab>
  <Tab value="Windows">
  ```powershell
  code $env:AppData\Claude\claude_desktop_config.json
  ```
  </Tab>
</Tabs>

然后您将在 `mcpServers` 键中添加您的服务器。只有在至少一个服务器正确配置的情况下，MCP UI 元素才会在 Claude 桌面版中显示。

在这种情况下，我们将添加单个天气服务器，如下所示：

<Tabs items={['MacOS/Linux', 'Windows']}>
  <Tab value="MacOS/Linux">
  ```json java
  {
    "mcpServers": {
      "kotlin-weather": {
        "command": "java",
        "args": [
          "-jar",
          "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar"
        ]
      }
    }
  }
  ```
  </Tab>

  <Tab value="Windows">
  ```json java
  {
    "mcpServers": {
      "kotlin-weather": {
        "command": "java",
        "args": [
          "-jar",
          "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\libs\\weather-0.1.0-all.jar"
        ]
      }
    }
  }
  ```
  </Tab>
</Tabs>

<Callout type="info">
务必使用服务器JAR文件的绝对路径，而不是相对路径。请将示例中的路径替换为您实际项目的完整路径。
</Callout>

这段配置向 Claude 桌面版说明：
1。有一个名为 "kotlin-weather" 的 MCP 服务器
2。需要通过运行 `java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar` 命令来启动它

完成配置后，保存文件并重新启动 **Claude 桌面版**应用程序。

</Tab>

<Tab value='C#'>
让我们开始构建天气服务器吧！[完整代码示例可在此查看](https://github.com/modelcontextprotocol/csharp-sdk/tree/main/samples/QuickstartWeatherServer)。

### 前提知识

本快速入门假设您已熟悉：
- C#编程语言
- 像 Claude 这样的大语言模型 (LLM)
- .NET 8 或更高版本

### 系统要求

- 已安装[.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) 或更高版本

### 环境设置

首先，如果您尚未安装.NET SDK，请先完成安装。您可以从[微软.NET 官网](https://dotnet.microsoft.com/download/)下载并安装。安装完成后，通过以下命令验证安装：
```bash
dotnet --version
```

接下来，创建并设置项目：

<Tabs items={['MacOS/Linux', 'Windows']}>
```bash tab="MacOS/Linux"
# 创建项目目录
mkdir weather
cd weather
# 初始化新的C#控制台项目
dotnet new console
```

```powershell tab="Windows"
# 创建项目目录
md weather
cd weather
# 初始化新的C#控制台项目
dotnet new console
```
</Tabs>

运行 `dotnet new console` 命令后，系统会生成一个新的 C#项目。
您可以使用您偏好的集成开发环境 (IDE) 打开项目，例如 [Visual Studio](https://visualstudio.microsoft.com/) 或 [Rider](https://www.jetbrains.com/rider/)。
或者，您也可以参考 [Visual Studio 项目向导](https://learn.microsoft.com/zh-cn/visualstudio/get-started/csharp/tutorial-console?view=vs-2022)创建 C#应用程序。

接下来，添加必要的 NuGet 包：

```bash
# 添加MCP（Model Context Protocol）SDK包
dotnet add package ModelContextProtocol --prerelease
# 添加.NET托管包
dotnet add package Microsoft.Extensions.Hosting
```

现在，让我们开始构建服务器。

## 构建服务器

打开项目中的 `Program.cs` 文件，将其内容替换为以下代码：

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using ModelContextProtocol;
using System.Net.Http.Headers;

var builder = Host.CreateEmptyApplicationBuilder(settings: null);

builder.Services.AddMcpServer()
    .WithStdioServerTransport()
    .WithToolsFromAssembly();

builder.Services.AddSingleton(_ =>
{
    var client = new HttpClient() { BaseAddress = new Uri("https://api.weather.gov") };
    client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue("weather-tool", "1.0"));
    return client;
});

var app = builder.Build();

await app.RunAsync();
```

<Callout type="info">
在创建`ApplicationHostBuilder`时，请确保使用`CreateEmptyApplicationBuilder`而非`CreateDefaultBuilder`。这样可以确保服务器不会向控制台输出任何额外信息，这对于使用标准输入/输出通信的服务器尤为重要。
</Callout>

上述代码设置了一个基本的控制台应用程序，使用 MCP SDK 创建了一个基于标准输入/输出传输的服务器。

### 天气 API 处理函数

接下来，定义一个包含工具执行处理函数的类，用于查询并格式化来自国家气象服务 API 的响应：

```csharp
using ModelContextProtocol.Server;
using System.ComponentModel;
using System.Net.Http.Json;
using System.Text.Json;

namespace QuickstartWeatherServer.Tools;

[McpServerToolType]
public static class WeatherTools
{
    [McpServerTool, Description("Get weather alerts for a US state.")] // 获取美国各州的天气警报
    public static async Task<string> GetAlerts(
        HttpClient client,
        [Description("The US state to get alerts for.")] string state) // 需要提供美国州的两字母代码（如CA、NY）
    {
        var jsonElement = await client.GetFromJsonAsync<JsonElement>($"/alerts/active/area/{state}");
        var alerts = jsonElement.GetProperty("features").EnumerateArray();

        if (!alerts.Any())
        {
            return "该州目前没有活跃的天气警报。";
        }

        return string.Join("\n--\n", alerts.Select(alert =>
        {
            JsonElement properties = alert.GetProperty("properties");
            return $"""
                    Event: {properties.GetProperty("event").GetString()}           // 事件类型（如暴风雨、洪水等）
                    Area: {properties.GetProperty("areaDesc").GetString()}         // 受影响区域
                    Severity: {properties.GetProperty("severity").GetString()}     // 严重程度
                    Description: {properties.GetProperty("description").GetString()} // 详细描述
                    Instruction: {properties.GetProperty("instruction").GetString()} // 安全指导和建议
                    """;
        }));
    }

    [McpServerTool, Description("Get weather forecast for a location.")] // 获取指定位置的天气预报
    public static async Task<string> GetForecast(
        HttpClient client,
        [Description("Latitude of the location.")] double latitude,    // 位置的纬度坐标
        [Description("Longitude of the location.")] double longitude)  // 位置的经度坐标
    {
        var jsonElement = await client.GetFromJsonAsync<JsonElement>($"/points/{latitude},{longitude}");
        var periods = jsonElement.GetProperty("properties").GetProperty("periods").EnumerateArray();

        return string.Join("\n---\n", periods.Select(period => $"""
                {period.GetProperty("name").GetString()}                          // 预报时段（如：今晚、明天、周三等）
                Temperature: {period.GetProperty("temperature").GetInt32()}°F     // 温度（华氏度）
                Wind: {period.GetProperty("windSpeed").GetString()} {period.GetProperty("windDirection").GetString()} // 风速和风向（如：5 mph SW）
                Forecast: {period.GetProperty("detailedForecast").GetString()}    // 详细天气预报
                """));
    }
}
```

### 运行服务器

使用以下命令构建并运行服务器：

```bash
dotnet run
```

此命令将启动服务器，并使其在标准输入/输出上监听传入的请求。

## 使用 Claude 桌面版测试服务器

<Callout type="info">
Claude桌面版目前尚未支持Linux系统。如果您使用的是Linux，请参考[构建客户端](/quickstart/client)教程，构建一个可连接到我们刚刚创建的服务器的MCP客户端。
</Callout>

首先，请确保您已安装 Claude 桌面版。[您可以在此下载最新版本](https://claude.ai/download)。如果您已经安装了 Claude 桌面版，**请务必确保它已更新至最新版本**。

接下来，需要为您的 MCP 服务器配置 Claude 桌面版。在文本编辑器中打开 Claude 桌面版的配置文件：

<Tabs items={['MacOS/Linux', 'Windows']}>
  <Tab value="MacOS/Linux">
  ```bash
  # 配置文件路径
  code ~/Library/Application\ Support/Claude/claude_desktop_config.json
  ```
  </Tab>
  <Tab value="Windows">
  ```powershell
  # 配置文件路径
  code $env:AppData\Claude\claude_desktop_config.json
  ```
  </Tab>
</Tabs>

如果该文件不存在，请创建它。

然后，在 `mcpServers` 键下添加您的服务器配置。请注意，只有至少配置了一个服务器时，Claude 桌面版中的 MCP 相关界面元素才会显示。

添加天气服务器的配置示例：

<Tabs items={['MacOS/Linux', 'Windows']}>
  <Tab value="MacOS/Linux">
  ```json
  {
    "mcpServers": {
      "weather": {
        "command": "dotnet",
        "args": [
          "run",
          "--project",
          "/您的项目绝对路径/weather",
          "--no-build"
        ]
      }
    }
  }
  ```
  </Tab>

  <Tab value="Windows">
  ```json
  {
    "mcpServers": {
      "weather": {
        "command": "dotnet",
        "args": [
          "run",
          "--project",
          "C:\\您的项目绝对路径\\weather",
          "--no-build"
        ]
      }
    }
  }
  ```
  </Tab>
</Tabs>

<Callout type="info">
**重要提示**：请务必使用项目的**绝对路径**，而非相对路径。将示例中的"/您的项目绝对路径/weather"或"C:\\您的项目绝对路径\\weather"替换为您实际项目的完整路径。
</Callout>

这段配置告诉 Claude 桌面版：
1。有一个名为 "weather" 的 MCP 服务器
2。需要通过运行 `dotnet run --project /您的项目绝对路径/weather --no-build` 命令来启动它

完成配置后，保存文件并重新启动 **Claude 桌面版**应用程序。

</Tab>

</Tabs>

### 功能测试

首先，让我们确认 Claude 桌面版能够识别我们在 `weather` 服务器中提供的两个工具。您可以通过界面中的锤子图标<img src="/images/claude-desktop-mcp-hammer-icon.svg" style={{display:'inline',margin:0,height:'1.3em'}} />来确认：

![](/images/visual-indicator-mcp-tools.png)

点击锤子图标后，您应该能看到可用工具列表：

![](/images/available-mcp-tools.png)

如果您的服务器没有被 Claude 桌面版识别，请查看下方[故障排除](#troubleshooting)部分获取调试建议。

如果锤子图标已正常显示，您可以通过在 Claude 桌面版中输入以下问题来测试服务器功能：

- 萨克拉门托的天气如何？
- 德克萨斯州有哪些活跃的天气警报？

![](/images/current-weather.png)

![](/images/weather-alerts.png)

<Callout type="info">
请注意，由于使用的是美国国家气象服务API，此服务仅支持查询美国地区的天气信息。
</Callout>

## 工作原理解析

当您向 Claude 提问时，背后发生了以下过程：

1. 客户端将您的问题发送给 Claude
2. Claude 分析可用工具并决定使用哪个工具来回答您的问题
3. 客户端通过 MCP 协议调用服务器上的相应工具
4. 工具执行结果返回给 Claude
5. Claude 根据工具返回的数据生成自然语言回答
6. 最终答案显示给您！

## 故障排除

<Accordions type="single">
<Accordion title="Claude桌面版集成问题">
**查看Claude桌面版日志**

与 MCP 相关的日志文件存储在以下位置：

- `mcp.log`：包含 MCP 连接和连接失败的一般日志信息
- `mcp-server-服务器名称.log`：包含特定服务器的错误 (stderr) 输出

您可以运行以下命令查看最近的日志并实时跟踪新日志：
```bash
# 查看Claude的MCP相关日志
tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
```

**服务器在 Claude 中未显示**

可能的解决方法：
1。检查 `claude_desktop_config.json` 文件的 JSON 语法是否正确
2。确认您使用的是绝对路径而非相对路径
3。完全退出并重新启动 Claude 桌面版

**工具调用无响应或失败**

如果 Claude 尝试使用工具但操作失败：
1。检查 Claude 的日志文件是否有错误信息
2。确认您的服务器能否单独正常构建和运行
3。尝试重启 Claude 桌面版
</Accordion>

<Accordion title="天气API问题">
**错误：无法检索网格点数据**

这通常意味着：
1。您提供的坐标位于美国境外 (此 API 仅支持美国地区)
2。国家气象服务 API 暂时出现问题
3。您的请求被 API 速率限制

解决方法：
- 确保使用美国境内的坐标
- 在多次请求之间添加适当延迟
- 查看 NWS API 的官方状态页面

**提示：某州没有活跃的警报**

这不是错误 - 它只是表明该州当前没有活跃的天气警报。您可以尝试查询其他州，或在恶劣天气期间再次检查。
</Accordion>
</Accordions>

<Callout type="info">
需更高级的故障排除技巧，请参考我们的[MCP调试指南](/docs/tools/debugging)
</Callout>

## 下一步

<Cards cols={2}>
  <Card
    title="构建客户端"
    icon={<Plug />}
    href="/quickstart/client"
  >
    学习如何构建自己的MCP客户端，连接到您的服务器
  </Card>
  <Card
    title="示例服务器"
    icon={<Grid3x3 />}
    href="/examples"
  >
    浏览我们的官方MCP服务器和实现示例库
  </Card>
  <Card
    title="调试指南"
    icon={<Bug />}
    href="/docs/tools/debugging"
  >
    学习如何有效调试MCP服务器和集成
  </Card>
  <Card
    title="使用LLM构建MCP"
    icon={<MessageCircle />}
    href="/tutorials/building-mcp-with-llms"
  >
    了解如何利用Claude等大语言模型加速MCP开发
  </Card>
</Cards>